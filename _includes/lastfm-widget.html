{% assign username = include.username | default: site.lastfm.username %}
{% assign api_key = include.api_key | default: site.lastfm.api_key %}

<fieldset class="lastfm-widget">
  <legend>Now Playing</legend>
  <div class="lastfm-content">
    <div class="lastfm-artwork">
      <img id="lastfm-album-art" src="" alt="Album artwork">
    </div>

    <div class="lastfm-info">
      <div class="lastfm-status">
        <span class="status-indicator" id="lastfm-status-indicator"></span>
        <span class="status-text" id="lastfm-status-text">Loading...</span>
      </div>

      <div class="lastfm-track">
        <div class="track-name" id="lastfm-track-name">—</div>
        <div class="track-artist" id="lastfm-artist-name">—</div>
        <div class="track-album" id="lastfm-album-name">—</div>
      </div>

      <div class="button-group">
        <button id="lastfm-refresh">Refresh</button>
        <button id="lastfm-link-btn">View on Last.fm</button>
      </div>
      <a href="#" id="lastfm-link" class="hidden" target="_blank" rel="noopener noreferrer"></a>
    </div>
  </div>

  <div class="lastfm-message hidden" id="lastfm-error">
    <span id="lastfm-error-text"></span>
  </div>
</fieldset>

<script>
(function() {
  'use strict';

  const LASTFM_API_URL = 'https://ws.audioscrobbler.com/2.0/';
  const USERNAME = '{{ username }}';
  const API_KEY = '{{ api_key }}';
  const UPDATE_INTERVAL = 120000; // 2 minutes
  const CACHE_KEY = 'lastfm_recent_track';
  const CACHE_TIMESTAMP_KEY = 'lastfm_cache_time';

  let elements = {};

  document.addEventListener('DOMContentLoaded', function() {
    initializeElements();

    const cached = getCachedData();
    if (cached) {
      updateUI(cached);
    }

    fetchAndUpdate();
    setInterval(fetchAndUpdate, UPDATE_INTERVAL);
  });

  function initializeElements() {
    elements = {
      artwork: document.getElementById('lastfm-album-art'),
      trackName: document.getElementById('lastfm-track-name'),
      artistName: document.getElementById('lastfm-artist-name'),
      albumName: document.getElementById('lastfm-album-name'),
      statusIndicator: document.getElementById('lastfm-status-indicator'),
      statusText: document.getElementById('lastfm-status-text'),
      link: document.getElementById('lastfm-link'),
      refreshButton: document.getElementById('lastfm-refresh'),
      error: document.getElementById('lastfm-error'),
      errorText: document.getElementById('lastfm-error-text'),
      content: document.querySelector('.lastfm-content')
    };

    // Add refresh button click handler
    if (elements.refreshButton) {
      elements.refreshButton.addEventListener('click', function() {
        manualRefresh();
      });
    }

    // Add Last.fm link button handler
    const linkBtn = document.getElementById('lastfm-link-btn');
    if (linkBtn && elements.link) {
      linkBtn.addEventListener('click', function() {
        window.open(elements.link.href, '_blank', 'noopener,noreferrer');
      });
    }
  }

  function manualRefresh() {
    if (elements.refreshButton && elements.refreshButton.disabled) {
      return; // Already refreshing
    }

    setRefreshingState(true);
    fetchAndUpdate(true);
  }

  function setRefreshingState(isRefreshing) {
    if (elements.refreshButton) {
      elements.refreshButton.disabled = isRefreshing;
    }
  }

  function fetchAndUpdate(isManual = false) {
    const url = `${LASTFM_API_URL}?method=user.getrecenttracks&user=${USERNAME}&api_key=${API_KEY}&format=json&limit=1`;

    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        if (!data.recenttracks || !data.recenttracks.track || data.recenttracks.track.length === 0) {
          showError('No recent tracks found');
          return;
        }

        const track = Array.isArray(data.recenttracks.track)
          ? data.recenttracks.track[0]
          : data.recenttracks.track;

        const trackData = parseTrackData(track);
        setCachedData(trackData);
        updateUI(trackData);
        hideError();

        if (isManual) {
          setRefreshingState(false);
        }
      })
      .catch(error => {
        console.error('Last.fm fetch error:', error);

        const cached = getCachedData();
        if (cached) {
          updateUI(cached);
        } else {
          showError('Unable to load track data');
        }

        if (isManual) {
          setRefreshingState(false);
        }
      });
  }

  function parseTrackData(track) {
    const isNowPlaying = track['@attr'] && track['@attr'].nowplaying === 'true';

    return {
      name: track.name || 'Unknown Track',
      artist: track.artist && track.artist['#text'] ? track.artist['#text'] : 'Unknown Artist',
      album: track.album && track.album['#text'] ? track.album['#text'] : 'Unknown Album',
      url: track.url || '#',
      image: getAlbumArtwork(track),
      nowPlaying: isNowPlaying
    };
  }

  function getAlbumArtwork(track) {
    const images = track.image || [];
    const preferredSizes = ['extralarge', 'large', 'medium'];

    for (const size of preferredSizes) {
      const img = images.find(i => i.size === size);
      if (img && img['#text']) {
        return img['#text'];
      }
    }

    return 'data:image/svg+xml,' + encodeURIComponent(
      '<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120">' +
      '<rect width="120" height="120" fill="#1e1e2e"/>' +
      '<text x="60" y="60" text-anchor="middle" dy=".3em" fill="#6c7086" font-size="12">No Image</text>' +
      '</svg>'
    );
  }

  function updateUI(trackData) {
    if (!elements.artwork) return;

    elements.artwork.src = trackData.image;
    elements.artwork.alt = trackData.album;
    elements.trackName.textContent = trackData.name;
    elements.artistName.textContent = trackData.artist;
    elements.albumName.textContent = trackData.album;
    elements.link.href = trackData.url;

    if (trackData.nowPlaying) {
      elements.statusIndicator.classList.add('now-playing');
      elements.statusText.textContent = 'Now Playing';
    } else {
      elements.statusIndicator.classList.remove('now-playing');
      elements.statusText.textContent = 'Last Played';
    }
  }

  function getCachedData() {
    try {
      const cached = localStorage.getItem(CACHE_KEY);
      const timestamp = localStorage.getItem(CACHE_TIMESTAMP_KEY);

      if (cached && timestamp) {
        const age = Date.now() - parseInt(timestamp);
        if (age < UPDATE_INTERVAL) {
          return JSON.parse(cached);
        }
      }
    } catch (e) {
      console.warn('Cache read failed:', e);
    }
    return null;
  }

  function setCachedData(data) {
    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify(data));
      localStorage.setItem(CACHE_TIMESTAMP_KEY, Date.now().toString());
    } catch (e) {
      console.warn('Cache write failed:', e);
    }
  }

  function showError(message) {
    if (elements.error && elements.errorText && elements.content) {
      elements.errorText.textContent = message;
      elements.error.classList.remove('hidden');
      elements.content.classList.add('hidden');
    }
  }

  function hideError() {
    if (elements.error && elements.content) {
      elements.error.classList.add('hidden');
      elements.content.classList.remove('hidden');
    }
  }
})();
</script>
